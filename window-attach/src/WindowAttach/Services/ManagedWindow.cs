using System;
using System.Windows;
using DependencyPropertyGenerator;
using Windows.Win32;
using Windows.Win32.Foundation;
using Windows.Win32.UI.WindowsAndMessaging;
using static Windows.Win32.PInvoke;
using WindowAttach.Models;
using WindowAttach.Utils;
using SET_WINDOW_POS_FLAGS = Windows.Win32.UI.WindowsAndMessaging.SET_WINDOW_POS_FLAGS;
using WINDOW_EX_STYLE = Windows.Win32.UI.WindowsAndMessaging.WINDOW_EX_STYLE;
using ModelsWindowState = WindowAttach.Models.WindowState;

namespace WindowAttach.Services
{
    /// <summary>
    /// Managed window that monitors window state through hooks
    /// Provides dependency properties for window properties like Title, IsVisible, IsActive, WindowState, etc.
    /// </summary>
    [DependencyProperty<string>("Title", DefaultValue = "")]
    [DependencyProperty<bool>("IsVisible", DefaultValue = true)]
    [DependencyProperty<bool>("IsActive", DefaultValue = false)]
    [DependencyProperty<ModelsWindowState>("WindowState", DefaultValue = ModelsWindowState.Normal)]
    [DependencyProperty<bool>("Topmost", DefaultValue = false)]
    [DependencyProperty<WindowRect?>("Bounds")]
    [DependencyProperty<double>("Opacity", DefaultValue = 1.0)]
    [DependencyProperty<IntPtr>("Owner")]
    [DependencyProperty<IntPtr>("Parent")]
    [DependencyProperty<uint>("ProcessId", DefaultValue = 0u)]
    [DependencyProperty<uint>("ThreadId", DefaultValue = 0u)]
    [DependencyProperty<uint>("ExStyle", DefaultValue = 0u)]
    [DependencyProperty<uint>("Style", DefaultValue = 0u)]
    public partial class ManagedWindow : DependencyObject, IDisposable
    {
        private readonly HWND _windowHandle;
        private WindowEventHook? _eventHook;
        private bool _isUpdatingFromHook;

        /// <summary>
        /// Event raised when Title property changes
        /// </summary>
        public event EventHandler<string>? TitleChanged;

        /// <summary>
        /// Event raised when IsVisible property changes
        /// </summary>
        public event EventHandler<bool>? IsVisibleChanged;

        /// <summary>
        /// Event raised when IsActive property changes
        /// </summary>
        public event EventHandler<bool>? IsActiveChanged;

        /// <summary>
        /// Event raised when WindowState property changes
        /// </summary>
        public event EventHandler<ModelsWindowState>? WindowStateChanged;

        /// <summary>
        /// Event raised when Topmost property changes
        /// </summary>
        public event EventHandler<bool>? TopmostChanged;

        /// <summary>
        /// Event raised when Bounds property changes
        /// </summary>
        public event EventHandler<WindowRect>? BoundsChanged;

        /// <summary>
        /// Event raised when Opacity property changes
        /// </summary>
        public event EventHandler<double>? OpacityChanged;

        /// <summary>
        /// Event raised when ExStyle property changes
        /// </summary>
        public event EventHandler<uint>? ExStyleChanged;

        /// <summary>
        /// Event raised when Style property changes
        /// </summary>
        public event EventHandler<uint>? StyleChanged;

        /// <summary>
        /// Window handle
        /// </summary>
        public IntPtr Handle => _windowHandle.Value;

        // Dependency properties are auto-generated by DependencyPropertyGenerator
        // Use partial methods for change callbacks
        partial void OnTitleChanged(string oldValue, string newValue)
        {
            TitleChanged?.Invoke(this, newValue);
            // Update actual window title if set from code
            if (!_isUpdatingFromHook && _windowHandle.Value != IntPtr.Zero && IsWindow(_windowHandle))
            {
                try
                {
                    Windows.Win32.PInvoke.SetWindowText(_windowHandle, newValue);
                }
                catch
                {
                    // Ignore errors when setting window title
                }
            }
        }

        partial void OnIsVisibleChanged(bool oldValue, bool newValue)
        {
            IsVisibleChanged?.Invoke(this, newValue);
        }

        partial void OnIsActiveChanged(bool oldValue, bool newValue)
        {
            IsActiveChanged?.Invoke(this, newValue);
        }

        partial void OnWindowStateChanged(ModelsWindowState oldValue, ModelsWindowState newValue)
        {
            WindowStateChanged?.Invoke(this, newValue);
            // Update actual window state if set from code
            if (!_isUpdatingFromHook && _windowHandle.Value != IntPtr.Zero && IsWindow(_windowHandle))
            {
                try
                {
                    SHOW_WINDOW_CMD cmd = newValue switch
                    {
                        ModelsWindowState.Minimized => SHOW_WINDOW_CMD.SW_MINIMIZE,
                        ModelsWindowState.Maximized => SHOW_WINDOW_CMD.SW_MAXIMIZE,
                        _ => SHOW_WINDOW_CMD.SW_RESTORE
                    };
                    ShowWindow(_windowHandle, cmd);
                }
                catch
                {
                    // Ignore errors when setting window state
                }
            }
        }

        partial void OnTopmostChanged(bool oldValue, bool newValue)
        {
            TopmostChanged?.Invoke(this, newValue);
            // Update actual window topmost state
            if (!_isUpdatingFromHook && _windowHandle.Value != IntPtr.Zero && IsWindow(_windowHandle))
            {
                // Use SetWindowZOrder to set topmost
                WindowHelper.SetWindowZOrder(_windowHandle.Value, newValue ? new IntPtr(-1) : new IntPtr(-2), SET_WINDOW_POS_FLAGS.SWP_NOMOVE | SET_WINDOW_POS_FLAGS.SWP_NOSIZE);
            }
        }

        partial void OnBoundsChanged(WindowRect? oldValue, WindowRect? newValue)
        {
            if (newValue.HasValue)
            {
                BoundsChanged?.Invoke(this, newValue.Value);
                // Update actual window bounds if set from code
                if (!_isUpdatingFromHook && _windowHandle.Value != IntPtr.Zero && IsWindow(_windowHandle))
                {
                    try
                    {
                        WindowHelper.SetWindowPos(_windowHandle.Value, newValue.Value.Left, newValue.Value.Top,
                            newValue.Value.Width, newValue.Value.Height,
                            SET_WINDOW_POS_FLAGS.SWP_NOZORDER | SET_WINDOW_POS_FLAGS.SWP_NOACTIVATE);
                    }
                    catch
                    {
                        // Ignore errors when setting window bounds
                    }
                }
            }
        }

        partial void OnOpacityChanged(double oldValue, double newValue)
        {
            OpacityChanged?.Invoke(this, newValue);
            // Update actual window opacity if set from code
            if (!_isUpdatingFromHook && _windowHandle.Value != IntPtr.Zero && IsWindow(_windowHandle))
            {
                try
                {
                    // Opacity is 0-255 in Win32 API
                    byte alpha = (byte)(Math.Max(0, Math.Min(1, newValue)) * 255);
                    Windows.Win32.PInvoke.SetLayeredWindowAttributes(_windowHandle, new Windows.Win32.Foundation.COLORREF(0), alpha, Windows.Win32.UI.WindowsAndMessaging.LAYERED_WINDOW_ATTRIBUTES_FLAGS.LWA_ALPHA);
                }
                catch
                {
                    // Ignore errors when setting window opacity
                }
            }
        }

        partial void OnOwnerChanged(IntPtr oldValue, IntPtr newValue)
        {
            // Update actual window owner if set from code
            if (!_isUpdatingFromHook && _windowHandle.Value != IntPtr.Zero && IsWindow(_windowHandle))
            {
                WindowHelper.SetWindowOwner(_windowHandle.Value, newValue);
            }
        }

        /// <summary>
        /// Create a managed window instance
        /// </summary>
        /// <param name="windowHandle">Window handle to monitor</param>
        public ManagedWindow(IntPtr windowHandle)
        {
            _windowHandle = new HWND(windowHandle);
            
            if (!IsWindow(_windowHandle))
                throw new ArgumentException("Invalid window handle");

            // Initialize all properties
            UpdateAllProperties();

            // Create event hook for real-time state detection
            _eventHook = new WindowEventHook(windowHandle);
            _eventHook.LocationChanged += EventHook_LocationChanged;
            _eventHook.VisibilityChanged += EventHook_VisibilityChanged;
            _eventHook.Activated += EventHook_Activated;
            _eventHook.Destroyed += EventHook_Destroyed;
            _eventHook.StartHook();
        }

        /// <summary>
        /// Update all window properties from actual window state
        /// </summary>
        private void UpdateAllProperties()
        {
            if (_windowHandle.Value == IntPtr.Zero || !IsWindow(_windowHandle))
                return;

            _isUpdatingFromHook = true;
            try
            {
                UpdateTitle();
                UpdateIsVisible();
                UpdateWindowState();
                UpdateIsActive();
                UpdateTopmost();
                UpdateBounds();
                UpdateOpacity();
                UpdateOwner();
                UpdateParent();
                UpdateProcessAndThreadId();
            }
            finally
            {
                _isUpdatingFromHook = false;
            }
        }

        /// <summary>
        /// Update window title
        /// </summary>
        private void UpdateTitle()
        {
            if (_windowHandle.Value == IntPtr.Zero || !IsWindow(_windowHandle))
                return;

            string title = WindowHelper.GetWindowText(_windowHandle.Value);
            if (Title != title)
            {
                Title = title;
            }
        }

        /// <summary>
        /// Update window visibility state
        /// </summary>
        private void UpdateIsVisible()
        {
            if (_windowHandle.Value == IntPtr.Zero || !IsWindow(_windowHandle))
                return;

            bool isVisible = IsWindowVisible(_windowHandle) && !IsIconic(_windowHandle);
            if (IsVisible != isVisible)
            {
                IsVisible = isVisible;
            }
        }

        /// <summary>
        /// Update window state (Normal, Minimized, Maximized)
        /// </summary>
        private void UpdateWindowState()
        {
            if (_windowHandle.Value == IntPtr.Zero || !IsWindow(_windowHandle))
                return;

            bool isMinimized = IsIconic(_windowHandle);
            bool isMaximized = Windows.Win32.PInvoke.IsZoomed(_windowHandle);
            
            ModelsWindowState newState;
            if (isMinimized)
                newState = ModelsWindowState.Minimized;
            else if (isMaximized)
                newState = ModelsWindowState.Maximized;
            else
                newState = ModelsWindowState.Normal;

            if (WindowState != newState)
            {
                WindowState = newState;
            }
        }

        /// <summary>
        /// Update window activation state
        /// </summary>
        private void UpdateIsActive()
        {
            if (_windowHandle.Value == IntPtr.Zero || !IsWindow(_windowHandle))
                return;

            var foregroundWindow = GetForegroundWindow();
            bool isActive = foregroundWindow.Value == _windowHandle.Value;
            if (IsActive != isActive)
            {
                IsActive = isActive;
            }
        }

        /// <summary>
        /// Update window topmost state
        /// </summary>
        private void UpdateTopmost()
        {
            if (_windowHandle.Value == IntPtr.Zero || !IsWindow(_windowHandle))
                return;

            bool isTopmost = WindowHelper.GetWindowTopmost(_windowHandle.Value);
            if (Topmost != isTopmost)
            {
                Topmost = isTopmost;
            }
        }

        /// <summary>
        /// Update window bounds
        /// </summary>
        private void UpdateBounds()
        {
            if (_windowHandle.Value == IntPtr.Zero || !IsWindow(_windowHandle))
                return;

            var rect = WindowHelper.GetWindowRect(_windowHandle.Value);
            if (rect.HasValue)
            {
                if (Bounds == null || !Bounds.Value.Equals(rect.Value))
                {
                    Bounds = rect;
                }
            }
            else
            {
                if (Bounds != null)
                {
                    Bounds = null;
                }
            }
        }

        /// <summary>
        /// Update window opacity
        /// </summary>
        private void UpdateOpacity()
        {
            if (_windowHandle.Value == IntPtr.Zero || !IsWindow(_windowHandle))
                return;

            // Get window extended style to check if layered window
            var exStyle = WindowHelper.GetWindowExStyle(_windowHandle.Value);
            if (exStyle.HasFlag(WINDOW_EX_STYLE.WS_EX_LAYERED))
            {
                // Try to get opacity (this requires additional API calls)
                // For now, default to 1.0 if layered window exists
                if (Opacity != 1.0)
                {
                    Opacity = 1.0;
                }
            }
        }

        /// <summary>
        /// Update window owner
        /// </summary>
        private void UpdateOwner()
        {
            if (_windowHandle.Value == IntPtr.Zero || !IsWindow(_windowHandle))
                return;

            var owner = WindowHelper.GetWindowOwner(_windowHandle.Value);
            if (Owner != owner)
            {
                Owner = owner;
            }
        }

        /// <summary>
        /// Update window parent
        /// </summary>
        private void UpdateParent()
        {
            if (_windowHandle.Value == IntPtr.Zero || !IsWindow(_windowHandle))
                return;

            var parent = WindowHelper.GetWindowParent(_windowHandle.Value);
            if (Parent != parent)
            {
                Parent = parent;
            }
        }

        /// <summary>
        /// Update process and thread ID
        /// </summary>
        private void UpdateProcessAndThreadId()
        {
            if (_windowHandle.Value == IntPtr.Zero || !IsWindow(_windowHandle))
                return;

            var processId = WindowHelper.GetWindowProcessId(_windowHandle.Value);
            var threadId = WindowHelper.GetWindowThreadId(_windowHandle.Value);
            
            if (ProcessId != processId)
            {
                ProcessId = processId;
            }
            
            if (ThreadId != threadId)
            {
                ThreadId = threadId;
            }
        }

        /// <summary>
        /// Update window extended style
        /// </summary>
        private void UpdateExStyle()
        {
            if (_windowHandle.Value == IntPtr.Zero || !IsWindow(_windowHandle))
                return;

            var exStyle = WindowHelper.GetWindowExStyle(_windowHandle.Value);
            uint exStyleValue = (uint)exStyle;
            if (ExStyle != exStyleValue)
            {
                ExStyle = exStyleValue;
            }
        }

        /// <summary>
        /// Update window style
        /// </summary>
        private void UpdateStyle()
        {
            if (_windowHandle.Value == IntPtr.Zero || !IsWindow(_windowHandle))
                return;

            var style = WindowHelper.GetWindowStyle(_windowHandle.Value);
            uint styleValue = (uint)style;
            if (Style != styleValue)
            {
                Style = styleValue;
            }
        }

        partial void OnExStyleChanged(uint oldValue, uint newValue)
        {
            ExStyleChanged?.Invoke(this, newValue);
        }

        partial void OnStyleChanged(uint oldValue, uint newValue)
        {
            StyleChanged?.Invoke(this, newValue);
        }

        private void EventHook_LocationChanged(IntPtr hwnd)
        {
            if (hwnd == _windowHandle.Value)
            {
                _isUpdatingFromHook = true;
                try
                {
                    UpdateBounds();
                    UpdateWindowState();
                    UpdateExStyle();
                    UpdateStyle();
                }
                finally
                {
                    _isUpdatingFromHook = false;
                }
            }
        }

        private void EventHook_VisibilityChanged(IntPtr hwnd, bool isVisible)
        {
            if (hwnd == _windowHandle.Value)
            {
                _isUpdatingFromHook = true;
                try
                {
                    IsVisible = isVisible;
                    UpdateWindowState();
                }
                finally
                {
                    _isUpdatingFromHook = false;
                }
            }
        }

        private void EventHook_Activated(IntPtr hwnd)
        {
            if (hwnd == _windowHandle.Value)
            {
                _isUpdatingFromHook = true;
                try
                {
                    UpdateIsActive();
                }
                finally
                {
                    _isUpdatingFromHook = false;
                }
            }
        }

        private void EventHook_Destroyed(IntPtr hwnd)
        {
            if (hwnd == _windowHandle.Value)
            {
                Dispose();
            }
        }

        public void Dispose()
        {
            if (_eventHook != null)
            {
                _eventHook.LocationChanged -= EventHook_LocationChanged;
                _eventHook.VisibilityChanged -= EventHook_VisibilityChanged;
                _eventHook.Activated -= EventHook_Activated;
                _eventHook.Destroyed -= EventHook_Destroyed;
                _eventHook.Dispose();
                _eventHook = null;
            }
        }
    }
}

