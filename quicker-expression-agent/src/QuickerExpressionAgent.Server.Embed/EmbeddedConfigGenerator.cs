using System;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;

namespace QuickerExpressionAgent.Server.Embed;

/// <summary>
/// Source generator to generate EmbeddedConfig from .env file at compile time
/// </summary>
[Generator]
public class EmbeddedConfigGenerator : ISourceGenerator
{
	public void Initialize(GeneratorInitializationContext context)
	{
		// No initialization needed
	}

	public void Execute(GeneratorExecutionContext context)
	{
		try
		{
			// Find .env file in AdditionalFiles
			string? envContent = null;
			foreach (var additionalFile in context.AdditionalFiles)
			{
				var fileName = Path.GetFileName(additionalFile.Path);
				if (fileName.Equals(".env", StringComparison.OrdinalIgnoreCase))
				{
					envContent = additionalFile.GetText()?.ToString();
					break;
				}
			}

			// Read .env file - read ApiKey, BaseUrl, and ModelId
			string apiKey = "";
			string baseUrl = "";
			string modelId = "";

			if (string.IsNullOrEmpty(envContent))
			{
				// Generate default values if .env file doesn't exist
				GenerateDefaultConfig(context);
				return;
			}

			var lines = envContent.Split(new[] { '\r', '\n' }, StringSplitOptions.RemoveEmptyEntries);

			foreach (var line in lines)
			{
				// Skip comments and empty lines
				var trimmedLine = line.Trim();
				if (string.IsNullOrEmpty(trimmedLine) || trimmedLine.StartsWith("#"))
					continue;

				// Parse KEY=VALUE format
				var match = Regex.Match(trimmedLine, @"^([^=]+)=(.*)$");
				if (match.Success)
				{
					var key = match.Groups[1].Value.Trim();
					var value = match.Groups[2].Value.Trim();

					// Remove quotes if present
					if ((value.StartsWith("\"") && value.EndsWith("\"")) ||
					    (value.StartsWith("'") && value.EndsWith("'")))
					{
						value = value.Substring(1, value.Length - 2);
					}

					switch (key.ToUpperInvariant())
					{
						case "OPENAI_API_KEY":
						case "OPENAI:APIKEY":
							apiKey = value;
							break;
						case "OPENAI_BASE_URL":
						case "OPENAI:BASEURL":
							baseUrl = value;
							break;
						case "OPENAI_MODEL_ID":
						case "OPENAI:MODELID":
							modelId = value;
							break;
					}
				}
			}

			// Generate C# code - ApiKey, BaseUrl, and ModelId
			var source = GenerateSourceCode(apiKey, baseUrl, modelId);
			context.AddSource("EmbeddedConfig.generated.cs", SourceText.From(source, Encoding.UTF8));
		}
		catch (Exception ex)
		{
			// Report diagnostic error
			var descriptor = new DiagnosticDescriptor(
				"EMBED001",
				"Failed to generate EmbeddedConfig",
				"Failed to generate EmbeddedConfig: {0}",
				"EmbeddedConfig",
				DiagnosticSeverity.Error,
				isEnabledByDefault: true);
			
			context.ReportDiagnostic(Diagnostic.Create(descriptor, Location.None, ex.Message));
			
			// Generate default config on error
			GenerateDefaultConfig(context);
		}
	}


	private void GenerateDefaultConfig(GeneratorExecutionContext context)
	{
		var source = GenerateSourceCode("", "", "");
		context.AddSource("EmbeddedConfig.generated.cs", SourceText.From(source, Encoding.UTF8));
	}

	private string GenerateSourceCode(string apiKey, string baseUrl, string modelId)
	{
		// Escape strings for C# string literals
		apiKey = EscapeString(apiKey);
		baseUrl = EscapeString(baseUrl);
		modelId = EscapeString(modelId);

		return $@"// <auto-generated />
// This file is generated at compile time from .env
// DO NOT EDIT THIS FILE MANUALLY

namespace QuickerExpressionAgent.Server.Generated;

/// <summary>
/// Embedded configuration generated at compile time
/// </summary>
internal static partial class EmbeddedConfig
{{
    internal static readonly string ApiKey = {apiKey};
    internal static readonly string BaseUrl = {baseUrl};
    internal static readonly string ModelId = {modelId};
}}
";
	}

	private static string EscapeString(string value)
	{
		if (string.IsNullOrEmpty(value))
			return "\"\"";

		// Escape special characters for C# string literal
		var escaped = value
			.Replace("\\", "\\\\")
			.Replace("\"", "\\\"")
			.Replace("\n", "\\n")
			.Replace("\r", "\\r")
			.Replace("\t", "\\t");

		return $"\"{escaped}\"";
	}
}

