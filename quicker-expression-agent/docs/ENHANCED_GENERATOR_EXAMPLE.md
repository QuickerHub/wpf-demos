# 增强版 API Key 生成器实现示例

## 概述

本文档提供了增强版的 MSBuild Task 实现，可以生成加密/混淆的 API Key 存储代码，增加提取难度。

## 实现方案

### 方案 1：XOR 加密生成器（简单版）

#### 实现代码

```csharp
using System;
using System.IO;
using System.Linq;
using System.Security.Cryptography;
using System.Text;
using System.Text.RegularExpressions;
using Microsoft.Build.Framework;
using Microsoft.Build.Utilities;

namespace QuickerExpressionAgent.Server.Embed;

/// <summary>
/// Enhanced MSBuild task to generate obfuscated EmbeddedConfig.cs
/// </summary>
public class GenerateObfuscatedConfigTask : Task
{
    [Required]
    public string EnvFilePath { get; set; } = string.Empty;

    [Required]
    public string OutputFilePath { get; set; } = string.Empty;

    public bool EnableObfuscation { get; set; } = true;

    public override bool Execute()
    {
        try
        {
            string apiKey = "";
            string baseUrl = "https://api.openai.com/v1";
            string modelId = "deepseek-chat";

            // Read from .env file (same as before)
            if (File.Exists(EnvFilePath))
            {
                var envContent = File.ReadAllText(EnvFilePath);
                var lines = envContent.Split(new[] { '\r', '\n' }, StringSplitOptions.RemoveEmptyEntries);

                foreach (var line in lines)
                {
                    var trimmedLine = line.Trim();
                    if (string.IsNullOrEmpty(trimmedLine) || trimmedLine.StartsWith("#"))
                        continue;

                    var match = Regex.Match(trimmedLine, @"^([^=]+)=(.*)$");
                    if (match.Success)
                    {
                        var key = match.Groups[1].Value.Trim();
                        var value = match.Groups[2].Value.Trim();

                        if ((value.StartsWith("\"") && value.EndsWith("\"")) ||
                            (value.StartsWith("'") && value.EndsWith("'")))
                        {
                            value = value.Substring(1, value.Length - 2);
                        }

                        switch (key.ToUpperInvariant())
                        {
                            case "OPENAI_API_KEY":
                            case "OPENAI:APIKEY":
                                apiKey = value;
                                break;
                            case "OPENAI_BASE_URL":
                            case "OPENAI:BASEURL":
                                baseUrl = value;
                                break;
                            case "OPENAI_MODEL_ID":
                            case "OPENAI:MODELID":
                                modelId = value;
                                break;
                        }
                    }
                }
            }

            // Generate obfuscated code
            var code = EnableObfuscation
                ? GenerateObfuscatedCode(apiKey, baseUrl, modelId)
                : GeneratePlainCode(apiKey, baseUrl, modelId);

            // Ensure output directory exists
            var outputDir = Path.GetDirectoryName(OutputFilePath);
            if (!string.IsNullOrEmpty(outputDir) && !Directory.Exists(outputDir))
            {
                Directory.CreateDirectory(outputDir);
            }

            // Write generated code
            File.WriteAllText(OutputFilePath, code, Encoding.UTF8);

            Log.LogMessage(MessageImportance.Normal, 
                $"Generated {(EnableObfuscation ? "obfuscated" : "plain")} EmbeddedConfig.cs from .env");
            return true;
        }
        catch (Exception ex)
        {
            Log.LogError($"Failed to generate EmbeddedConfig.cs: {ex.Message}");
            return false;
        }
    }

    /// <summary>
    /// Generate plain code (original implementation)
    /// </summary>
    private string GeneratePlainCode(string apiKey, string baseUrl, string modelId)
    {
        apiKey = EscapeString(apiKey);
        baseUrl = EscapeString(baseUrl);
        modelId = EscapeString(modelId);

        return $@"// <auto-generated />
// This file is generated at compile time from .env
// DO NOT EDIT THIS FILE MANUALLY

namespace QuickerExpressionAgent.Server.Generated;

internal static class EmbeddedConfig
{{
    public static string ApiKey => {apiKey};
    public static string BaseUrl => {baseUrl};
    public static string ModelId => {modelId};
}}";
    }

    /// <summary>
    /// Generate obfuscated code with XOR encryption
    /// </summary>
    private string GenerateObfuscatedCode(string apiKey, string baseUrl, string modelId)
    {
        // Generate random encryption key (different for each build)
        var random = new Random();
        var keyBytes = new byte[4];
        random.NextBytes(keyBytes);
        var keyHex = string.Join(", ", keyBytes.Select(b => $"0x{b:X2}"));

        // Encrypt strings
        var encryptedApiKey = EncryptXor(apiKey, keyBytes);
        var encryptedBaseUrl = EncryptXor(baseUrl, keyBytes);
        var encryptedModelId = EncryptXor(modelId, keyBytes);

        // Generate byte array strings
        var apiKeyBytes = FormatByteArray(encryptedApiKey);
        var baseUrlBytes = FormatByteArray(encryptedBaseUrl);
        var modelIdBytes = FormatByteArray(encryptedModelId);

        return $@"// <auto-generated />
// This file is generated at compile time from .env
// DO NOT EDIT THIS FILE MANUALLY

using System.Text;

namespace QuickerExpressionAgent.Server.Generated;

/// <summary>
/// Embedded configuration generated at compile time (obfuscated)
/// </summary>
internal static class EmbeddedConfig
{{
    private static readonly byte[] _key = new byte[] {{ {keyHex} }};
    
    private static readonly byte[] _encryptedApiKey = new byte[] {{ {apiKeyBytes} }};
    private static readonly byte[] _encryptedBaseUrl = new byte[] {{ {baseUrlBytes} }};
    private static readonly byte[] _encryptedModelId = new byte[] {{ {modelIdBytes} }};

    public static string ApiKey => Decrypt(_encryptedApiKey);
    public static string BaseUrl => Decrypt(_encryptedBaseUrl);
    public static string ModelId => Decrypt(_encryptedModelId);

    private static string Decrypt(byte[] encrypted)
    {{
        if (encrypted == null || encrypted.Length == 0)
            return string.Empty;

        var decrypted = new byte[encrypted.Length];
        for (int i = 0; i < encrypted.Length; i++)
        {{
            decrypted[i] = (byte)(encrypted[i] ^ _key[i % _key.Length]);
        }}
        return Encoding.UTF8.GetString(decrypted);
    }}
}}";
    }

    /// <summary>
    /// Encrypt string using XOR
    /// </summary>
    private byte[] EncryptXor(string plainText, byte[] key)
    {
        if (string.IsNullOrEmpty(plainText))
            return Array.Empty<byte>();

        var bytes = Encoding.UTF8.GetBytes(plainText);
        var encrypted = new byte[bytes.Length];
        for (int i = 0; i < bytes.Length; i++)
        {
            encrypted[i] = (byte)(bytes[i] ^ key[i % key.Length]);
        }
        return encrypted;
    }

    /// <summary>
    /// Format byte array as C# code
    /// </summary>
    private string FormatByteArray(byte[] bytes)
    {
        if (bytes == null || bytes.Length == 0)
            return string.Empty;

        return string.Join(", ", bytes.Select(b => $"0x{b:X2}"));
    }

    private static string EscapeString(string value)
    {
        if (string.IsNullOrEmpty(value))
            return "\"\"";

        var escaped = value
            .Replace("\\", "\\\\")
            .Replace("\"", "\\\"")
            .Replace("\n", "\\n")
            .Replace("\r", "\\r")
            .Replace("\t", "\\t");

        return $"\"{escaped}\"";
    }
}
```

#### 生成的代码示例

```csharp
// <auto-generated />
// This file is generated at compile time from .env
// DO NOT EDIT THIS FILE MANUALLY

using System.Text;

namespace QuickerExpressionAgent.Server.Generated;

internal static class EmbeddedConfig
{
    private static readonly byte[] _key = new byte[] { 0x12, 0x34, 0x56, 0x78 };
    
    private static readonly byte[] _encryptedApiKey = new byte[] { 
        0x7B, 0x47, 0x15, 0x2D, 0x5E, 0x7A, 0x3C, 0x1F, ...
    };
    private static readonly byte[] _encryptedBaseUrl = new byte[] { 
        0x79, 0x45, 0x13, 0x2B, ...
    };
    private static readonly byte[] _encryptedModelId = new byte[] { 
        0x7D, 0x49, 0x17, 0x2F, ...
    };

    public static string ApiKey => Decrypt(_encryptedApiKey);
    public static string BaseUrl => Decrypt(_encryptedBaseUrl);
    public static string ModelId => Decrypt(_encryptedModelId);

    private static string Decrypt(byte[] encrypted)
    {
        if (encrypted == null || encrypted.Length == 0)
            return string.Empty;

        var decrypted = new byte[encrypted.Length];
        for (int i = 0; i < encrypted.Length; i++)
        {
            decrypted[i] = (byte)(encrypted[i] ^ _key[i % _key.Length]);
        }
        return Encoding.UTF8.GetString(decrypted);
    }
}
```

---

### 方案 2：字符串分割混淆生成器（进阶版）

#### 实现代码

```csharp
/// <summary>
/// Generate code with string splitting obfuscation
/// </summary>
private string GenerateSplitObfuscatedCode(string apiKey, string baseUrl, string modelId)
{
    // Split strings into parts
    var apiKeyParts = SplitString(apiKey, 4);
    var baseUrlParts = SplitString(baseUrl, 6);
    var modelIdParts = SplitString(modelId, 5);

    // Generate random order indices
    var random = new Random();
    var apiKeyOrder = Enumerable.Range(0, apiKeyParts.Length).OrderBy(x => random.Next()).ToArray();
    var baseUrlOrder = Enumerable.Range(0, baseUrlParts.Length).OrderBy(x => random.Next()).ToArray();
    var modelIdOrder = Enumerable.Range(0, modelIdParts.Length).OrderBy(x => random.Next()).ToArray();

    // Format parts and orders
    var apiKeyPartsStr = FormatStringArray(apiKeyParts);
    var baseUrlPartsStr = FormatStringArray(baseUrlParts);
    var modelIdPartsStr = FormatStringArray(modelIdParts);

    var apiKeyOrderStr = FormatIntArray(apiKeyOrder);
    var baseUrlOrderStr = FormatIntArray(baseUrlOrder);
    var modelIdOrderStr = FormatIntArray(modelIdOrder);

    return $@"// <auto-generated />
// This file is generated at compile time from .env
// DO NOT EDIT THIS FILE MANUALLY

using System.Text;

namespace QuickerExpressionAgent.Server.Generated;

internal static class EmbeddedConfig
{{
    private static readonly string[] _apiKeyParts = new[] {{ {apiKeyPartsStr} }};
    private static readonly string[] _baseUrlParts = new[] {{ {baseUrlPartsStr} }};
    private static readonly string[] _modelIdParts = new[] {{ {modelIdPartsStr} }};

    private static readonly int[] _apiKeyOrder = new[] {{ {apiKeyOrderStr} }};
    private static readonly int[] _baseUrlOrder = new[] {{ {baseUrlOrderStr} }};
    private static readonly int[] _modelIdOrder = new[] {{ {modelIdOrderStr} }};

    public static string ApiKey => Combine(_apiKeyParts, _apiKeyOrder);
    public static string BaseUrl => Combine(_baseUrlParts, _baseUrlOrder);
    public static string ModelId => Combine(_modelIdParts, _modelIdOrder);

    private static string Combine(string[] parts, int[] order)
    {{
        if (parts == null || parts.Length == 0)
            return string.Empty;

        var sb = new StringBuilder();
        foreach (var idx in order)
        {{
            if (idx >= 0 && idx < parts.Length)
            {{
                sb.Append(parts[idx]);
            }}
        }}
        return sb.ToString();
    }}
}}";
}

/// <summary>
/// Split string into parts
/// </summary>
private string[] SplitString(string value, int partLength)
{
    if (string.IsNullOrEmpty(value))
        return Array.Empty<string>();

    var parts = new List<string>();
    for (int i = 0; i < value.Length; i += partLength)
    {
        var length = Math.Min(partLength, value.Length - i);
        parts.Add(value.Substring(i, length));
    }
    return parts.ToArray();
}

/// <summary>
/// Format string array as C# code
/// </summary>
private string FormatStringArray(string[] values)
{
    if (values == null || values.Length == 0)
        return string.Empty;

    return string.Join(", ", values.Select(v => EscapeString(v)));
}

/// <summary>
/// Format int array as C# code
/// </summary>
private string FormatIntArray(int[] values)
{
    if (values == null || values.Length == 0)
        return string.Empty;

    return string.Join(", ", values);
}
```

---

### 方案 3：混合混淆生成器（高级版）

#### 实现代码

```csharp
/// <summary>
/// Generate code with mixed obfuscation techniques
/// </summary>
private string GenerateMixedObfuscatedCode(string apiKey, string baseUrl, string modelId)
{
    var random = new Random();
    
    // Generate random variable names to confuse reverse engineers
    var varNames = GenerateRandomNames(random, 10);
    
    // Encrypt with XOR
    var keyBytes = new byte[4];
    random.NextBytes(keyBytes);
    var keyHex = string.Join(", ", keyBytes.Select(b => $"0x{b:X2}"));

    var encryptedApiKey = EncryptXor(apiKey, keyBytes);
    var encryptedBaseUrl = EncryptXor(baseUrl, keyBytes);
    var encryptedModelId = EncryptXor(modelId, keyBytes);

    // Split into multiple arrays
    var apiKeyChunks = SplitIntoChunks(encryptedApiKey, 8);
    var baseUrlChunks = SplitIntoChunks(encryptedBaseUrl, 8);
    var modelIdChunks = SplitIntoChunks(encryptedModelId, 8);

    // Generate code with fake variables and real data mixed
    var fakeVars = new StringBuilder();
    for (int i = 0; i < 5; i++)
    {
        var fakeBytes = new byte[8];
        random.NextBytes(fakeBytes);
        fakeVars.AppendLine($"    private static readonly byte[] {varNames[i]} = new byte[] {{ {FormatByteArray(fakeBytes)} }};");
    }

    var apiKeyArrays = new StringBuilder();
    for (int i = 0; i < apiKeyChunks.Length; i++)
    {
        apiKeyArrays.AppendLine($"    private static readonly byte[] {varNames[5 + i]} = new byte[] {{ {FormatByteArray(apiKeyChunks[i])} }};");
    }

    // Similar for baseUrl and modelId...

    return $@"// <auto-generated />
// This file is generated at compile time from .env
// DO NOT EDIT THIS FILE MANUALLY

using System.Text;
using System.Linq;

namespace QuickerExpressionAgent.Server.Generated;

internal static class EmbeddedConfig
{{
    // Fake variables to confuse reverse engineers
{fakeVars}
    
    // Real encrypted data (mixed with fake)
{apiKeyArrays}
    
    private static readonly byte[] _key = new byte[] {{ {keyHex} }};
    
    // Fake methods
    private static void {varNames[9]}() {{ }}
    private static int {varNames[8]}(int x) => x * 2;

    public static string ApiKey => Decrypt(new[] {{ {string.Join(", ", Enumerable.Range(5, apiKeyChunks.Length).Select(i => varNames[i]))} }});
    public static string BaseUrl => Decrypt(new[] {{ ... }});
    public static string ModelId => Decrypt(new[] {{ ... }});

    private static string Decrypt(byte[][] chunks)
    {{
        var combined = chunks.SelectMany(c => c).ToArray();
        var decrypted = new byte[combined.Length];
        for (int i = 0; i < combined.Length; i++)
        {{
            decrypted[i] = (byte)(combined[i] ^ _key[i % _key.Length]);
        }}
        return Encoding.UTF8.GetString(decrypted);
    }}
}}";
}

/// <summary>
/// Generate random variable names
/// </summary>
private string[] GenerateRandomNames(Random random, int count)
{
    var names = new List<string>();
    for (int i = 0; i < count; i++)
    {
        var name = "_" + GenerateRandomString(random, 8);
        names.Add(name);
    }
    return names.ToArray();
}

/// <summary>
/// Generate random string
/// </summary>
private string GenerateRandomString(Random random, int length)
{
    const string chars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
    return new string(Enumerable.Repeat(chars, length)
        .Select(s => s[random.Next(s.Length)]).ToArray());
}

/// <summary>
/// Split byte array into chunks
/// </summary>
private byte[][] SplitIntoChunks(byte[] data, int chunkSize)
{
    var chunks = new List<byte[]>();
    for (int i = 0; i < data.Length; i += chunkSize)
    {
        var length = Math.Min(chunkSize, data.Length - i);
        var chunk = new byte[length];
        Array.Copy(data, i, chunk, 0, length);
        chunks.Add(chunk);
    }
    return chunks.ToArray();
}
```

---

## 使用方法

### 1. 更新 MSBuild Task

将 `GenerateEmbeddedConfigTask` 替换为增强版本，或添加新的 Task。

### 2. 更新 .targets 文件

```xml
<Target Name="GenerateEmbeddedConfig" BeforeTargets="BeforeBuild" 
        Condition="Exists('$(MSBuildProjectDirectory)\.env')" 
        DependsOnTargets="BuildEmbedTask">
    <GenerateObfuscatedConfigTask
        EnvFilePath="$(MSBuildProjectDirectory)\.env"
        OutputFilePath="$(MSBuildProjectDirectory)\Generated\EmbeddedConfig.cs"
        EnableObfuscation="true">
        <Output TaskParameter="OutputFilePath" ItemName="GeneratedFile" />
    </GenerateObfuscatedConfigTask>
    <ItemGroup>
        <Compile Include="@(GeneratedFile)" />
    </ItemGroup>
</Target>
```

### 3. 配置选项

可以通过 MSBuild 属性控制混淆：

```xml
<PropertyGroup>
    <EnableConfigObfuscation>true</EnableConfigObfuscation>
</PropertyGroup>
```

---

## 安全注意事项

1. **XOR 加密较弱**：
   - 仅增加提取难度，不能完全防止
   - 应该配合代码混淆工具使用

2. **密钥随机性**：
   - 每次编译生成不同的密钥
   - 增加静态分析的难度

3. **虚假代码**：
   - 添加虚假变量和方法
   - 混淆真实的数据结构

4. **配合其他措施**：
   - 代码混淆（ConfuserEx、Obfuscar）
   - 反调试保护
   - API Key 使用限制

---

## 性能影响

- **XOR 加密**：几乎无性能影响（O(n)）
- **字符串分割**：轻微性能影响（字符串拼接）
- **混合混淆**：中等性能影响（取决于复杂度）

**建议**：在安全性和性能之间平衡，根据实际需求选择方案。

---

## 总结

| 方案 | 安全性 | 性能 | 实现难度 | 推荐度 |
|------|--------|------|----------|--------|
| XOR 加密 | ⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐ | ⭐⭐⭐⭐ |
| 字符串分割 | ⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐ | ⭐⭐⭐ |
| 混合混淆 | ⭐⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ |

**推荐实施顺序**：
1. ✅ 实现 XOR 加密版本（快速，有效）
2. ✅ 添加字符串分割（可选）
3. ⏳ 实现混合混淆（高级需求）

